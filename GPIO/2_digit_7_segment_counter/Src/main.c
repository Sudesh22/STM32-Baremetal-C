/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include "stm32f1xx.h"
//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

void MCO_pin_conf(){
	RCC->APB2RSTR |= RCC_APB2RSTR_IOPARST; // Reset GPIOA
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPARST; // Clear reset

	RCC->APB2RSTR |= RCC_APB2RSTR_IOPBRST; // Reset GPIOB
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPBRST; // Clear reset

	RCC->APB2RSTR |= RCC_APB2RSTR_IOPCRST; // Reset GPIOC
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPCRST; // Clear reset

	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

//PA1 - CLOCKPIN
	GPIOA->CRL &= ~(GPIO_CRL_MODE1 | GPIO_CRL_CNF1 );

	//CONFIGURE GPIO PINMODE AS OUTPUT MAX SPEED 50MHZ
	GPIOA->CRL |= (GPIO_CRL_MODE1_1 | GPIO_CRL_MODE1_0 );

	//CONFIGURE GPIO OUTPUT MODE AS OUTPUT PUSH PULL
	GPIOA->CRL |= ~(GPIO_CRL_CNF1_1 | GPIO_CRL_CNF1_0);


//PC14 - LATCHPIN & PC13 - LATCHPIN2
	GPIOC->CRH &= ~(GPIO_CRH_MODE14 | GPIO_CRH_CNF14 | GPIO_CRH_MODE13 | GPIO_CRH_CNF13);

	//CONFIGURE GPIO PINMODE AS OUTPUT MAX SPEED 50MHZ
	GPIOC->CRH |= (GPIO_CRH_MODE14_1 | GPIO_CRH_MODE14_0 | GPIO_CRH_MODE13_1 | GPIO_CRH_MODE13_0);

	//CONFIGURE GPIO OUTPUT MODE AS OUTPUT PUSH PULL
	GPIOC->CRH |= ~(GPIO_CRH_CNF14_1 | GPIO_CRH_CNF14_0 | GPIO_CRH_CNF13_1 | GPIO_CRH_CNF13_0);


//PB8 - DATAPIN
	GPIOB->CRH &= ~(GPIO_CRH_MODE8 | GPIO_CRH_CNF8);

	//CONFIGURE GPIO PINMODE AS OUTPUT MAX SPEED 50MHZ
	GPIOB->CRH |= (GPIO_CRH_MODE8_1 | GPIO_CRH_MODE8_0);

	//CONFIGURE GPIO OUTPUT MODE AS OUTPUT PUSH PULL
	GPIOB->CRH |= ~(GPIO_CRH_CNF8_1 | GPIO_CRH_CNF8_0);

}


void system_clk()
{
	//ENABLE HSE AND WAIT TILL IT BECOMES READY
	RCC->CR |= RCC_CR_HSEON;	//HSE @8MHZ
	while(!(RCC->CR & RCC_CR_HSERDY))
		;

	//CONFIGURE FLASH PREFETCH AND LATENCY SETTINGS
	FLASH->ACR |= FLASH_ACR_PRFTBE|FLASH_ACR_LATENCY_1;

	//CONFIGURE PLL AND BUSES (AHB,APB1,APB2)
	//PLL SOURCE: HERE HSE IS USED AS A SOURCE
	RCC->CFGR |= RCC_CFGR_PLLSRC;
	//HSE DIVIDER FOR PLL (IF HSE IS USED AS SOURCE FOR PLL)
	RCC->CFGR |= RCC_CFGR_PLLXTPRE_HSE;	//INPUT TO PLL 8MHZ
	//PLL MULTIPLIER: HERE HSE OUTPUT IS MULTIPLIED WITH 4
	RCC->CFGR |= RCC_CFGR_PLLMULL4;	//OUTPUT TO PLL IS 32MHZ
	//BUS CLOCK CONFIGURE(APB1,APB2,AHB): NOT DIVIDING
	RCC->CFGR |= (RCC_CFGR_PPRE1_DIV1|RCC_CFGR_PPRE2_DIV1|RCC_CFGR_HPRE_DIV1);
	//ENABLE THE PLL
	RCC->CR |= RCC_CR_PLLON;
	//WAIT FOR PLL TO SET
	while(!(RCC->CR & RCC_CR_PLLRDY))
		;

	//ENABLE SYSTEMCLK AND WAIT
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL))
		;

	MCO_pin_conf();
	//CLOCK OUTPUT ON MCO PIN
	RCC->CFGR |= RCC_CFGR_MCO_SYSCLK;
}


/* Timer Frequency (TF) = bus Clock(Fsysclk)/(Prescaler(TIM2PSC) + 1)
 *
 * Timer tim Period (TTM) = 1/timer frequency(TF)
 *
 * Time delay by timer = Timer Time Period * Timer Auto Reload Register(TIM2ARR)
 *
 * System clock = 32MHz, TIM2PSC = 32, so TF = 1MHz
 *
 * TTP = 1us
 * TIM2AEE = 0xffff
 */


void delay_us(uint16_t us) {
    uint16_t start = TIM2->CNT; // Capture the current counter value
    while ((TIM2->CNT - start) < us); // Wait until the elapsed time matches 'us'
}


void delay_ms(uint16_t ms){
	for (uint16_t i=0; i<ms; i++)
		delay_us(1000);
}

void shiftOut(bool mode, uint8_t data){
	bool output;
	for(uint8_t i=0; i<8; i++){
		if (mode==1){							//MSBFIRST = 1, LSBFIRST = 0
			output = data & 0x80;
			data = data << 1;
		}
		else{
			output = data & 0x01;
			data = data >> 1;
		}
		if (output==1){
			GPIOB->ODR |= GPIO_ODR_ODR8;		// Set the pin HIGH if bit is 1
		}
		else{
			GPIOB->ODR &= ~GPIO_ODR_ODR8;		// Set the pin LOW if bit is 0
		}
		GPIOA->ODR |= GPIO_ODR_ODR1;			// Send the bit by pulling clock HIGH
		delay_ms(1);
		GPIOA->ODR &= ~GPIO_ODR_ODR1;           // Pull clock LOW when done and go for next bit
		delay_ms(1);
	}
}


void timer_init(){
	//Start by making sure that the timer's 'counter' is off
	TIM2->CR1 &= ~(TIM_CR1_CEN);
	TIM2->SR &= ~(TIM_SR_UIF);

	//RESET THE TIMER2 BUS
	RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST);
	RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST);

	//ENABLE THE TIMER2 PERIPHERAL CLOCK
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;


	/**********Eg1************/
	//Timer Prescaler value
	TIM2->PSC = 31;

	//Timer Auto Reload Register Value
	TIM2->ARR = 0xffff;

	//ENABLE THE UPDATE GENERATION
	TIM2->EGR |= TIM_EGR_UG;

	TIM2->CR1 |=TIM_CR1_CEN;
//	while(!(TIM2->SR & (1<<TIM_SR_UIF)));
}

int main(void)
{
	system_clk();
	timer_init();
	uint8_t data[16] = {0xFC, 0x60, 0xDA, 0xF2, 0x66, 0xB6, 0xBE, 0xE0, 0xFE, 0xF6, 0xEE, 0x3E, 0x9C, 0x7A, 0x9E, 0x8E};

	while(1){
		for(uint8_t j=0; j<10; j++){
			//Pull LatchPin LOW to keep LEDs from changing while reading serial data
			GPIOC->BSRR = GPIO_BSRR_BR13;
			GPIOC->BSRR = GPIO_BSRR_BR14;
			shiftOut(1, data[j]);
			//Pull LatchPin HIGH to change LEDs
			GPIOC->BSRR = GPIO_BSRR_BS13;

			delay_ms(1);
			//Pull LatchPin LOW to keep LEDs from changing while reading serial data
			GPIOC->BSRR = GPIO_BSRR_BR13;
//			delay_ms(1000);

			for(uint8_t i=0; i<10; i++){
				//Pull LatchPin LOW to keep LEDs from changing while reading serial data
				GPIOC->BSRR = GPIO_BSRR_BR14;

				shiftOut(1, data[i]);

				//Pull LatchPin HIGH to change LEDs
				GPIOC->BSRR = GPIO_BSRR_BS14;
				delay_ms(1000);
			}
		}
	}
}
