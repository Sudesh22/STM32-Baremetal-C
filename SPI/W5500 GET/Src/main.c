/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"
#include <stdbool.h>

void GPIO_Init(void) {
	RCC->APB2RSTR |= RCC_APB2RSTR_IOPARST;
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPARST;
	RCC->APB2RSTR |= RCC_APB2RSTR_IOPBRST;
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPBRST;
	RCC->APB2RSTR |= RCC_APB2RSTR_IOPCRST;
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPCRST;

	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN | RCC_APB2ENR_IOPCEN;
//	RCC->AHBENR |= RCC_AHBENR_DMA1EN;
	// Configure PB0 as output, max speed 50MHz, push-pull
	GPIOB->CRL &= ~(GPIO_CRL_MODE0 | GPIO_CRL_CNF0);
	GPIOB->CRL |= GPIO_CRL_MODE0_1; // Output 2 MHz push-pull

}

void system_clk()
{
	//ENABLE HSE AND WAIT TILL IT BECOMES READY
	RCC->CR |= RCC_CR_HSEON;	//HSE @8MHZ
	while(!(RCC->CR & RCC_CR_HSERDY))
		;

	//CONFIGURE FLASH PREFETCH AND LATENCY SETTINGS
	FLASH->ACR |= FLASH_ACR_PRFTBE|FLASH_ACR_LATENCY_1;

	//CONFIGURE PLL AND BUSES (AHB,APB1,APB2)
	//PLL SOURCE: HERE HSE IS USED AS A SOURCE
	RCC->CFGR |= RCC_CFGR_PLLSRC;
	//HSE DIVIDER FOR PLL (IF HSE IS USED AS SOURCE FOR PLL)
	RCC->CFGR |= RCC_CFGR_PLLXTPRE_HSE;	//INPUT TO PLL 8MHZ
	//PLL MULTIPLIER: HERE HSE OUTPUT IS MULTIPLIED WITH 4
	RCC->CFGR |= RCC_CFGR_PLLMULL4;	//OUTPUT TO PLL IS 32MHZ
	//BUS CLOCK CONFIGURE(APB1,APB2,AHB): NOT DIVIDING
	RCC->CFGR |= (RCC_CFGR_PPRE1_DIV1|RCC_CFGR_PPRE2_DIV1|RCC_CFGR_HPRE_DIV1);
	//ENABLE THE PLL
	RCC->CR |= RCC_CR_PLLON;
	//WAIT FOR PLL TO SET
	while(!(RCC->CR & RCC_CR_PLLRDY))
		;

	//ENABLE SYSTEMCLK AND WAIT
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL))
		;

	GPIO_Init();
	//CLOCK OUTPUT ON MCO PIN
	RCC->CFGR |= RCC_CFGR_MCO_SYSCLK;
}


/* Timer Frequency (TF) = bus Clock(Fsysclk)/(Prescaler(TIM2PSC) + 1)
 *
 * Timer tim Period (TTM) = 1/timer frequency(TF)
 *
 * Time delay by timer = Timer Time Period * Timer Auto Reload Register(TIM2ARR)
 *
 * System clock = 32MHz, TIM2PSC = 32, so TF = 1MHz
 *
 * TTP = 1us
 * TIM2AEE = 0xffff
 */


void delay_us(uint16_t us) {
    uint16_t start = TIM2->CNT; // Capture the current counter value
    while ((TIM2->CNT - start) < us); // Wait until the elapsed time matches 'us'
}


void delay_ms(uint16_t ms){
	for (uint16_t i=0; i<ms; i++)
		delay_us(1000);
}

void timer_init(){
	//Start by making sure that the timer's 'counter' is off
	TIM2->CR1 &= ~(TIM_CR1_CEN);
	TIM2->SR &= ~(TIM_SR_UIF);

	//RESET THE TIMER2 BUS
	RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST);
	RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST);

	//ENABLE THE TIMER2 PERIPHERAL CLOCK
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;


	/**********Eg1************/
	//Timer Prescaler value
	TIM2->PSC = 31;

	//Timer Auto Reload Register Value
	TIM2->ARR = 0xffff;

	//ENABLE THE UPDATE GENERATION
	TIM2->EGR |= TIM_EGR_UG;

	TIM2->CR1 |=TIM_CR1_CEN;
//	while(!(TIM2->SR & (1<<TIM_SR_UIF)));
}

#include "stm32f1xx.h"
#include <stdint.h>
#include <stdbool.h>

void SPI1_GPIO_Init(void) {
	// Enable GPIOA clock
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;

	// PA4: CS (manual NSS) — output push-pull, 2 MHz
	GPIOA->CRL &= ~(GPIO_CRL_MODE4 | GPIO_CRL_CNF4);
	GPIOA->CRL |= GPIO_CRL_MODE4_1;     // Output 2 MHz
	GPIOA->CRL &= ~GPIO_CRL_CNF4;       // Push-pull
	GPIOA->BSRR = GPIO_BSRR_BS4;        // Idle high

	// PA5: SCK — AF push-pull, 50 MHz
	GPIOA->CRL &= ~(GPIO_CRL_MODE5 | GPIO_CRL_CNF5);
	GPIOA->CRL |= (GPIO_CRL_MODE5_0 | GPIO_CRL_MODE5_1);  // Output 50 MHz
	GPIOA->CRL |= GPIO_CRL_CNF5_1;                        // AF push-pull
	GPIOA->CRL &= ~GPIO_CRL_CNF5_0;

	// PA6: MISO — input floating
	GPIOA->CRL &= ~(GPIO_CRL_MODE6 | GPIO_CRL_CNF6);
	GPIOA->CRL |= GPIO_CRL_CNF6_0; // Floating input

	// PA7: MOSI — AF push-pull, 50 MHz
	GPIOA->CRL &= ~(GPIO_CRL_MODE7 | GPIO_CRL_CNF7);
	GPIOA->CRL |= (GPIO_CRL_MODE7_0 | GPIO_CRL_MODE7_1);  // Output 50 MHz
	GPIOA->CRL |= GPIO_CRL_CNF7_1;                        // AF push-pull
	GPIOA->CRL &= ~GPIO_CRL_CNF7_0;

	// Ensure SPI1 remap is disabled (use PA5/6/7)
	AFIO->MAPR &= ~AFIO_MAPR_SPI1_REMAP;
}

void SPI1_Init(void) {
	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
	SPI1_GPIO_Init();

	SPI1->CR1 = 0x0000;
	SPI1->CR2 = 0x0000;

	// Master mode
	SPI1->CR1 |= SPI_CR1_MSTR;

	// Software slave management enabled
	SPI1->CR1 |= SPI_CR1_SSM;
	SPI1->CR1 |= SPI_CR1_SSI;

	// Clock polarity = 0, clock phase = 0  (SPI mode 0)
	SPI1->CR1 &= ~(SPI_CR1_CPOL | SPI_CR1_CPHA);

	// Baud rate = fPCLK/8
	SPI1->CR1 &= ~(SPI_CR1_BR);
	SPI1->CR1 |= SPI_CR1_BR_1; // 010: fPCLK/8

	// Enable SPI
	SPI1->CR1 |= SPI_CR1_SPE;
}

static inline void SPI1_CS_Low(void)  { GPIOA->BRR  = GPIO_BRR_BR4; }
static inline void SPI1_CS_High(void) { GPIOA->BSRR = GPIO_BSRR_BS4; }

uint8_t SPI1_Transfer(uint8_t data) {
	while ((SPI1->SR & SPI_SR_TXE) == 0);   // Wait TX empty
	SPI1->DR = data;                         // Write data
	while ((SPI1->SR & SPI_SR_RXNE) == 0);  // Wait RX not empty
	return SPI1->DR;                         // Read data
}

void SPI1_SetSpeed(uint8_t br)
{
    SPI1->CR1 &= ~SPI_CR1_SPE;   // Disable SPI before changing speed
    SPI1->CR1 &= ~SPI_CR1_BR;    // Clear prescaler bits
    SPI1->CR1 |= (br << 3);      // Set new BR[2:0] value
    SPI1->CR1 |= SPI_CR1_SPE;    // Enable SPI again
}

void SPI1_Transmit(uint8_t *data, uint16_t size)
{
    for (uint16_t i = 0; i < size; i++) {
        while (!(SPI1->SR & SPI_SR_TXE));
        SPI1->DR = data[i];
        while (!(SPI1->SR & SPI_SR_RXNE));
        (void)SPI1->DR; // Clear RX buffer
    }
}

void SPI1_Receive(uint8_t *buffer, uint16_t size)
{
    for (uint16_t i = 0; i < size; i++) {
        while (!(SPI1->SR & SPI_SR_TXE));   // Wait until TX buffer empty
        SPI1->DR = 0xFF;                   // Send dummy byte to generate clock
        while (!(SPI1->SR & SPI_SR_RXNE)); // Wait until RX buffer not empty
        buffer[i] = SPI1->DR;              // Read received byte
    }
}


void SPI1_TransmitReceive(uint8_t *txData, uint8_t *rxData, uint16_t size)
{
    for (uint16_t i = 0; i < size; i++) {
        while (!(SPI1->SR & SPI_SR_TXE));
        SPI1->DR = txData[i];
        while (!(SPI1->SR & SPI_SR_RXNE));
        rxData[i] = SPI1->DR;
    }
}

void SPI1_WaitBusy(void)
{
    while (SPI1->SR & SPI_SR_BSY);
}

void SPI1_DMA_Init(uint8_t *txBuf, uint8_t *rxBuf, uint16_t size) {
    // Disable channels before configuration
    DMA1_Channel2->CCR &= ~DMA_CCR_EN; // RX
    DMA1_Channel3->CCR &= ~DMA_CCR_EN; // TX

    // RX Channel (DMA1_Channel2)
    DMA1_Channel2->CPAR = (uint32_t)&SPI1->DR; // Peripheral address
    DMA1_Channel2->CMAR = (uint32_t)rxBuf;     // Memory address
    DMA1_Channel2->CNDTR = size;               // Number of data items
    DMA1_Channel2->CCR =
        DMA_CCR_MINC |       // Increment memory
        DMA_CCR_PL_1 |       // Priority High
        DMA_CCR_CIRC;        // Optional: circular if needed
    DMA1_Channel2->CCR |= DMA_CCR_EN; // Enable RX channel

    // TX Channel (DMA1_Channel3)
    DMA1_Channel3->CPAR = (uint32_t)&SPI1->DR; // Peripheral address
    DMA1_Channel3->CMAR = (uint32_t)txBuf;     // Memory address
    DMA1_Channel3->CNDTR = size;
    DMA1_Channel3->CCR =
        DMA_CCR_MINC |       // Increment memory
        DMA_CCR_DIR |        // Memory to peripheral
        DMA_CCR_PL_1;        // Priority High
    DMA1_Channel3->CCR |= DMA_CCR_EN; // Enable TX channel

    // Enable SPI DMA requests
    SPI1->CR2 |= SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
}

void SPI1_DMA_TransmitReceive(uint8_t *txBuf, uint8_t *rxBuf, uint16_t size) {
    SPI1_DMA_Init(txBuf, rxBuf, size);

    // Start SPI transfer
    SPI1_CS_Low();

    // DMA handles everything now, CPU is free
}

bool SPI1_DMA_TransferDone(void) {
    // RX channel complete flag
    if (DMA1->ISR & DMA_ISR_TCIF2) {
        DMA1->IFCR |= DMA_IFCR_CTCIF2; // Clear flag
        SPI1_CS_High();                // Release CS
        return true;
    }
    return false;
}


//uint8_t txData[3] = { 0x9F, 0x20, 0x00 };
//uint8_t rxData[3];
//int main(void) {
//	system_clk();
//	timer_init();
//	SPI1_Init();
//
//	uint8_t send = 0xA5;
//	uint8_t recv;
//
//
//
//	while (1) {
////		SPI1_CS_Low();
////		recv = SPI1_Transfer(send);
////		SPI1_CS_High();
//
//
//
//
//		SPI1_CS_Low();
//		SPI1_TransmitReceive(txData, rxData, 3);
//		SPI1_CS_High();
//		SPI1_WaitBusy();
//
//		for (int i = 0; i < 3; i++) {
//		    // you can inspect rxData[i]
//		}
//
//
//		delay_ms(500);
//	}
//}

//uint8_t txData[3] = {0x9F, 0x20, 0xff};
//uint8_t rxData[3];
//
//int main(void) {
//    system_clk();
//    timer_init();
//    SPI1_Init();
//
//    while(1) {
//        // Start SPI transfer once
//        SPI1_DMA_TransmitReceive(txData, rxData, 3);
//
//        // Blink LED until DMA completes
//        while (!SPI1_DMA_TransferDone()) {
//            GPIOC->BSRR = GPIO_BSRR_BR13;  // LED ON
//            delay_ms(100);
//            GPIOC->BSRR = GPIO_BSRR_BS13;  // LED OFF
//            delay_ms(100);
//        }
//
//        delay_ms(500);  // Wait a bit before next transfer
//    }
//}

uint8_t addr[2];
uint8_t ctrl[1];
uint8_t rxData[3];
uint8_t ver;
uint8_t mode;
uint8_t control;
uint16_t source_port;
uint16_t dest_port;

struct ipAddr{
	uint8_t oct1;
	uint8_t oct2;
	uint8_t oct3;
	uint8_t oct4;
};

struct ipAddr gar_ip;
struct ipAddr source_ip;
struct ipAddr dest_ip;
struct ipAddr subr_ip;

struct macAddr{
	uint8_t oct1;
	uint8_t oct2;
	uint8_t oct3;
	uint8_t oct4;
	uint8_t oct5;
	uint8_t oct6;
};

struct macAddr shar;
struct macAddr dhar;

void get_GAR(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x01;

	// Select read(0x80) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x03;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive((uint8_t*)&gar_ip, 4);
	SPI1_CS_High();
}

void set_GAR(uint8_t oct1, uint8_t oct2, uint8_t oct3, uint8_t oct4){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x01;

	// Select write(0x00) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x07;

	uint8_t tx_buf[7] = {
				addr[0],
				addr[1],
				ctrl[0],
				oct1,
				oct2,
				oct3,
				oct4
		};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 7);
	SPI1_CS_High();
}

void get_SIPAR(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x0F;

	// Select read(0x80) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x03;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive((uint8_t*)&source_ip, 4);
	SPI1_CS_High();
}

void set_SIPAR(uint8_t oct1, uint8_t oct2, uint8_t oct3, uint8_t oct4){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x0F;

	// Select write(0x00) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x07;

	uint8_t tx_buf[7] = {
				addr[0],
				addr[1],
				ctrl[0],
				oct1,
				oct2,
				oct3,
				oct4
		};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 7);
	SPI1_CS_High();
}

void get_ver(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x39;

	// Select read(0x80) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x03;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive(&ver, 1);
	SPI1_CS_High();
}

void W5500_Reset(void){
	GPIOB->BSRR = GPIO_BSRR_BR0; // Low
	delay_ms(10);
	GPIOB->BSRR = GPIO_BSRR_BS0; // High
	delay_ms(100);
}

void set_SUBR(uint8_t a, uint8_t b, uint8_t c, uint8_t d) {
    uint8_t tx_buf[7] = {0x00, 0x05, 0x07, a, b, c, d};
    SPI1_CS_Low();
    SPI1_Transmit(tx_buf, 7);
    SPI1_WaitBusy();
    SPI1_CS_High();
}

void get_SUBR(void) {
    uint8_t tx_buf[3] = {0x00, 0x05, 0x03};
    SPI1_CS_Low();
    SPI1_Transmit(tx_buf, 3);
    SPI1_Receive((uint8_t*)&subr_ip, 4);
    SPI1_WaitBusy();
    SPI1_CS_High();
}

void get_SHAR(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x09;

	// Select read(0x80) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x00;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive((uint8_t*)&shar, 6);
	SPI1_CS_High();
}

void set_SHAR(uint8_t oct1, uint8_t oct2, uint8_t oct3, uint8_t oct4, uint8_t oct5, uint8_t oct6){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x09;

	// Select write(0x00) and OM(0x00) 11 for n bytes
	ctrl[0] = 0x04;


	SPI1_CS_Low();
	SPI1_Transmit(addr, 2);
	SPI1_Transmit(ctrl, 1);
	SPI1_Transmit(&oct1, 1);
	SPI1_Transmit(&oct2, 1);
	SPI1_Transmit(&oct3, 1);
	SPI1_Transmit(&oct4, 1);
	SPI1_Transmit(&oct5, 1);
	SPI1_Transmit(&oct6, 1);
	SPI1_CS_High();
}

void get_DHAR(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x06;

	// Select read(0x80) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x08;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive((uint8_t*)&dhar, 6);
	SPI1_CS_High();
}

void set_DHAR(uint8_t oct1, uint8_t oct2, uint8_t oct3, uint8_t oct4, uint8_t oct5, uint8_t oct6){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x06;

	// Select write(0x00) and OM(0x00) 11 for n bytes
	ctrl[0] = 0x0C;


	SPI1_CS_Low();
	SPI1_Transmit(addr, 2);
	SPI1_Transmit(ctrl, 1);
	SPI1_Transmit(&oct1, 1);
	SPI1_Transmit(&oct2, 1);
	SPI1_Transmit(&oct3, 1);
	SPI1_Transmit(&oct4, 1);
	SPI1_Transmit(&oct5, 1);
	SPI1_Transmit(&oct6, 1);
	SPI1_CS_High();
}

void get_DIPR(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x0C;

	// Select read(0x00) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x0B;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive((uint8_t*)&dest_ip, 4);
	SPI1_CS_High();
}

void set_DIPR(uint8_t oct1, uint8_t oct2, uint8_t oct3, uint8_t oct4){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x0C;

	// Select write(0x00) and OM(0x00) 11 for n bytes
	ctrl[0] = 0x0F;


	SPI1_CS_Low();
	SPI1_Transmit(addr, 2);
	SPI1_Transmit(ctrl, 1);
	SPI1_Transmit(&oct1, 1);
	SPI1_Transmit(&oct2, 1);
	SPI1_Transmit(&oct3, 1);
	SPI1_Transmit(&oct4, 1);
	SPI1_CS_High();
}

void get_SNMR0(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x00;

	// Select read(0x00) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x08;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive((uint8_t*)&mode, 1);
	SPI1_CS_High();
}

void set_SNMR0(uint8_t mode){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x00;

	// Select write(0x00) and OM(0x00) 11 for n bytes
	ctrl[0] = 0x0C;


	SPI1_CS_Low();
	SPI1_Transmit(addr, 2);
	SPI1_Transmit(ctrl, 1);
	SPI1_Transmit(&mode, 1);
	SPI1_CS_High();
}

void get_SNCR(){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x01;

	// Select read(0x00) and OM(0x03) 11 for 4 bytes
	ctrl[0] = 0x08;

	uint8_t tx_buf[3] = {
			addr[0],
			addr[1],
			ctrl[0]
	};

	SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive(&control, 1);
	SPI1_CS_High();
}

void set_SNCR(uint8_t control){

	// Selecting Addr of Gateway IP Address Register
	addr[0] = 0x00;
	addr[1] = 0x01;

	// Select write(0x00) and OM(0x00) 11 for n bytes
	ctrl[0] = 0x0C;


	SPI1_CS_Low();
	SPI1_Transmit(addr, 2);
	SPI1_Transmit(ctrl, 1);
	SPI1_Transmit(&control, 1);
	SPI1_CS_High();
}

void get_SNSR() {
    addr[0] = 0x00;
    addr[1] = 0x03;
    ctrl[0] = 0x08; // Read socket 0 register

    uint8_t tx_buf[3] = { addr[0], addr[1], ctrl[0] };

    SPI1_CS_Low();
    SPI1_Transmit(tx_buf, 3);
    SPI1_Receive(&control, 1);  // reuse 'control' variable for status
    SPI1_CS_High();
}

void get_SNSPR(void) {
    // Socket 0 Source Port Register (Sn_PORT)
    addr[0] = 0x00;
    addr[1] = 0x04;

    // Read, Socket 0 block (BSB=00001), OM=00 (1 or 2 bytes)
    ctrl[0] = 0x08;   // 0000 1000 → BSB=00001, RWB=0, OM=00

    uint8_t tx_buf[3] = { addr[0], addr[1], ctrl[0] };
    uint8_t rx_buf[2];

    SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive(rx_buf, 2);
	SPI1_CS_High();

	// Convert big-endian bytes to uint16_t
	source_port = ((uint16_t)rx_buf[0] << 8) | rx_buf[1];
}

void set_SNSPR(uint16_t port) {
    // Socket 0 Source Port Register (Sn_PORT)
    addr[0] = 0x00;
    addr[1] = 0x04;

    // Write, Socket 0 block (BSB=00001), OM=00 (1 or 2 bytes)
    ctrl[0] = 0x0C;   // 0000 1100 → BSB=00001, RWB=1, OM=00
    uint8_t port_bytes[2] = { (port >> 8) & 0xFF, port & 0xFF }; // big-endian

    SPI1_CS_Low();
    SPI1_Transmit(addr, 2);
    SPI1_Transmit(ctrl, 1);
    SPI1_Transmit(port_bytes, 2);
    SPI1_CS_High();
}

void get_SNDPR(void) {
    // Socket 0 Source Port Register (Sn_PORT)
    addr[0] = 0x00;
    addr[1] = 0x10;

    // Read, Socket 0 block (BSB=00001), OM=00 (1 or 2 bytes)
    ctrl[0] = 0x08;   // 0000 1000 → BSB=00001, RWB=0, OM=00

    uint8_t tx_buf[3] = { addr[0], addr[1], ctrl[0] };
    uint8_t rx_buf[2];

    SPI1_CS_Low();
	SPI1_Transmit(tx_buf, 3);
	SPI1_Receive(rx_buf, 2);
	SPI1_CS_High();

	// Convert big-endian bytes to uint16_t
	dest_port = ((uint16_t)rx_buf[0] << 8) | rx_buf[1];
}

void set_SNDPR(uint16_t port) {
    // Socket 0 Source Port Register (Sn_PORT)
    addr[0] = 0x00;
    addr[1] = 0x10;

    // Write, Socket 0 block (BSB=00001), OM=00 (1 or 2 bytes)
    ctrl[0] = 0x0C;   // 0000 1100 → BSB=00001, RWB=1, OM=00
    uint8_t port_bytes[2] = { (port >> 8) & 0xFF, port & 0xFF }; // big-endian

    SPI1_CS_Low();
    SPI1_Transmit(addr, 2);
    SPI1_Transmit(ctrl, 1);
    SPI1_Transmit(port_bytes, 2);
    SPI1_CS_High();
}

void set_RCR(uint8_t count) {
    uint8_t addr[2] = { 0x00, 0x19 };
    uint8_t ctrl[1] = { 0x04 }; // Write, common register
    SPI1_CS_Low();
    SPI1_Transmit(addr, 2);
    SPI1_Transmit(ctrl, 1);
    SPI1_Transmit(&count, 1);
    SPI1_CS_High();
}

void set_RTR(uint16_t time) {
    uint8_t addr[2] = { 0x00, 0x17 };
    uint8_t ctrl[1] = { 0x04 };
    uint8_t data[2] = { (time >> 8) & 0xFF, time & 0xFF };
    SPI1_CS_Low();
    SPI1_Transmit(addr, 2);
    SPI1_Transmit(ctrl, 1);
    SPI1_Transmit(data, 2);
    SPI1_CS_High();
}

void set_MR_noARP(void) {
    uint8_t addr[2] = {0x00, 0x00};   // MR address
    uint8_t ctrl[1] = {0x0C};         // Write, OM=00 (1 byte)
    uint8_t value = 0x00;             // FARP = 0, default mode

    SPI1_CS_Low();
    SPI1_Transmit(addr, 2);
    SPI1_Transmit(ctrl, 1);
    SPI1_Transmit(&value, 1);
    SPI1_CS_High();
}

//uint8_t arp_packet[42];
//
//void build_arp_request(uint8_t *dst_mac, struct macAddr src_mac,struct ipAddr src_ip, struct ipAddr target_ip) {
//    // Ethernet header
//    for (int i = 0; i < 6; i++) arp_packet[i] = dst_mac[i];       // Destination MAC
//    arp_packet[6] = src_mac.oct1;     // Source MAC
//    arp_packet[7] = src_mac.oct2;     // Source MAC
//    arp_packet[8] = src_mac.oct3;     // Source MAC
//    arp_packet[9] = src_mac.oct4;     // Source MAC
//    arp_packet[10] = src_mac.oct5;     // Source MAC
//    arp_packet[11] = src_mac.oct6;     // Source MAC
//
//    arp_packet[12] = 0x08;  // EtherType high byte
//    arp_packet[13] = 0x06;  // EtherType low byte (ARP)
//
//    // ARP header
//    arp_packet[14] = 0x00; arp_packet[15] = 0x01; // Hardware type = Ethernet
//    arp_packet[16] = 0x08; arp_packet[17] = 0x00; // Protocol type = IPv4
//    arp_packet[18] = 6;  // Hardware size (MAC)
//    arp_packet[19] = 4;  // Protocol size (IP)
//    arp_packet[20] = 0x00; arp_packet[21] = 0x01; // Opcode = request
//
//    // Sender MAC
//    arp_packet[22] = src_mac.oct1;     // Source MAC
//	arp_packet[23] = src_mac.oct2;     // Source MAC
//	arp_packet[24] = src_mac.oct3;     // Source MAC
//	arp_packet[25] = src_mac.oct4;     // Source MAC
//	arp_packet[26] = src_mac.oct5;     // Source MAC
//	arp_packet[27] = src_mac.oct6;     // Source MAC
//
//    // Sender IP
//    arp_packet[28] = src_ip.oct1;
//    arp_packet[29] = src_ip.oct2;
//    arp_packet[30] = src_ip.oct3;
//    arp_packet[31] = src_ip.oct4;
//
//    // Target MAC = 0 for ARP request
//    for (int i = 0; i < 6; i++) arp_packet[32+i] = 0x00;
//
//    // Target IP
//    arp_packet[38] = target_ip.oct1;
//    arp_packet[39] = target_ip.oct2;
//    arp_packet[40] = target_ip.oct3;
//    arp_packet[41] = target_ip.oct4;
//}

// ---------- W5500 low-level write (single byte) ----------
static inline void W5500_Write(uint16_t addr, uint8_t data) {
    // Common register write: BSB = 00000 (common regs), write = 0x04
    uint8_t tx[3] = { (uint8_t)(addr >> 8), (uint8_t)(addr & 0xFF), 0x04 };
    SPI1_CS_Low();
    SPI1_Transmit(tx, 3);
    SPI1_Transmit(&data, 1);
    SPI1_CS_High();
}

// ---------- W5500 low-level read (single byte) ----------
static inline uint8_t W5500_Read(uint16_t addr) {
    // Common register read: BSB = 00000 (common regs), read = 0x00
    uint8_t tx[3] = { (uint8_t)(addr >> 8), (uint8_t)(addr & 0xFF), 0x00 };
    uint8_t rx;

    SPI1_CS_Low();
    SPI1_Transmit(tx, 3);
    SPI1_Receive(&rx, 1);  // read 1 byte into rx
    SPI1_CS_High();

    return rx;
}



// ---------- Helper: read 16-bit register (big-endian) ----------
static inline uint16_t W5500_Read16(uint16_t addr_hi) {
	uint8_t hi = W5500_Read(addr_hi);
	uint8_t lo = W5500_Read(addr_hi + 1);
	return ((uint16_t)hi << 8) | lo; }

static inline void W5500_Write16(uint16_t addr_hi, uint16_t val) {
	uint8_t hi = (val >> 8) & 0xFF;
	uint8_t lo = val & 0xFF;
	W5500_Write(addr_hi, hi);
	W5500_Write(addr_hi + 1, lo);
}
// TX write pointer
void set_Sn_TX_WR(uint8_t sock, uint16_t ptr) {
    uint16_t addr = 0x0024 + (sock * 0x100);
    W5500_Write(addr, (ptr >> 8) & 0xFF);
    W5500_Write(addr + 1, ptr & 0xFF);
}

uint16_t get_Sn_TX_WR(uint8_t sock) {
	uint8_t addr[2] = {0x00, 0x24};
	uint8_t ctrl[1] = {0x0A};
    uint8_t rx[2];

    SPI1_CS_Low();
    SPI1_Transmit(addr, 2);
    SPI1_Transmit(ctrl, 1);
    SPI1_Receive(rx, 2);
    SPI1_CS_High();

    return ((uint16_t)rx[0] << 8) | rx[1];
}

uint16_t get_Sn_TX_FSR(uint8_t sock) {
	uint8_t addr[2] = {0x00, 0x20};
	uint8_t ctrl[1] = {0x0A};

    uint8_t rx[2];
    SPI1_CS_Low();
    SPI1_Transmit(addr, 2);
    SPI1_Transmit(ctrl, 1);
    SPI1_Receive(rx, 2); // read both bytes at once
    SPI1_CS_High();

    return ((uint16_t)rx[0] << 8) | rx[1];
}


void send_data(uint8_t sock, const uint8_t *buf, uint16_t len) {
    uint16_t ptr = get_Sn_TX_WR(sock);
    uint16_t base = 0x6000 + (sock * 0x0800); // base per socket
    uint16_t start_addr = base + (ptr & 0x7FF);

    for (uint16_t i = 0; i < len; i++)
        W5500_Write(start_addr + i, buf[i]);

    ptr += len;
    set_Sn_TX_WR(sock, ptr);

    W5500_Write(0x4001 + (sock * 0x100), 0x20); // SEND command
    while (W5500_Read(0x4001 + (sock * 0x100)) != 0x00);
}

#include <string.h>

// Example GET request
//const char http_get_req[] =
//    "GET / HTTP/1.1\r\n"
//    "Host: 192.168.0.32\r\n"
//    "Connection: close\r\n"
//    "\r\n";

//void send_http_get(void) {
//    uint16_t tx_free_size, tx_wr_ptr;
//    uint16_t len = strlen(http_get_req);
//
//    // 1️⃣ Read TX free size
//    tx_free_size = get_Sn_TX_FSR(0);  // socket 0
//    while (tx_free_size < len) {
//        tx_free_size = get_Sn_TX_FSR(0);
//    }
//
//    // 2️⃣ Read current TX Write Pointer
//    tx_wr_ptr = get_Sn_TX_WR(0);
//
//    // 3️⃣ Calculate physical address in TX buffer
//    uint16_t offset = tx_wr_ptr & 0x07FF;  // modulo 2K for each socket buffer
//    uint16_t addr = 0x4000 + offset;       // 0x4000 = socket 0 TX buffer base
//
//    // 4️⃣ Write GET request data
//    W5500_write_data(addr, (uint8_t*)http_get_req, len);
//
//    // 5️⃣ Update TX Write Pointer
//    tx_wr_ptr += len;
//    set_Sn_TX_WR(0, tx_wr_ptr);
//
//    // 6️⃣ Send command
//    set_SNCR(0x20);  // SEND command
//    while (get_SNCR() != 0); // Wait till SEND clears
//}
//
//int main(void) {
//    system_clk();
//    timer_init();
//    SPI1_Init();
//
//    delay_ms(10);
//    W5500_Reset();
//    delay_ms(100);
//
//    get_ver();
//    set_GAR(192, 168, 0, 1);
//    delay_ms(100);
//    set_SIPAR(192, 168, 0, 100);
//    set_SUBR(255,255,255,0);
//    set_SHAR(0x00, 0x08, 0xDC, 0xAB, 0xCD, 0xEF);
//    set_DIPR(192, 168, 0, 32);
//
//    set_RCR(1);
//    set_RTR(0x1388);
//    set_MR_noARP();
//
//    while (1) {
//        set_SNMR0(1); // TCP mode
//        set_SNCR(1);  // OPEN
//        delay_ms(100);
//
//        if (get_SNSR() == 0x13) {  // ESTABLISHED
//            send_http_get();
//        }
//
//        // Optional: close socket later
//        if (control == 0x17) {
//            set_SNCR(0x08);   // DISCON
//            delay_ms(100);
//            set_SNCR(0x10);   // CLOSE
//        }
//
//        delay_ms(2000);
//    }
//}

// ---------- W5500 socket 0 TX buffer write ----------
static inline void W5500_Socket0_Write(uint16_t offset, const uint8_t *data, uint16_t len) {
    // Make sure offset is within 2 KB circular buffer
    offset &= 0x07FF;              // modulo 2 KB
    uint16_t addr = 0x0000 + offset; // socket 0 TX buffer base = 0x0000

    // Each byte is written one by one
    for (uint16_t i = 0; i < len; i++) {
        uint8_t tx[3] = { (uint8_t)(addr >> 8), (uint8_t)(addr & 0xFF), 0x14 };
        // 0x14 = BSB = 00010 (Socket 0 TX), write = 0x04, combined -> 0x14
        SPI1_CS_Low();
        SPI1_Transmit(tx, 3);
        SPI1_Transmit(&data[i], 1);
        SPI1_CS_High();

        addr++;  // increment address in TX buffer
        addr &= 0x07FF; // wrap around 2 KB
    }
}


const char http_get_req[] =
	"GET / HTTP/1.1\r\n"
	"Host: 192.168.0.32\r\n"
	"Connection: close\r\n"
	"\r\n";

uint16_t tx_free_size, tx_wr_ptr;
uint16_t get_len = strlen(http_get_req);
uint8_t response[512];
uint16_t rx_size;

int main(void) {
	system_clk();
	timer_init();
	SPI1_Init();

	delay_ms(10);
	W5500_Reset();
	delay_ms(100);

	get_ver();
	set_GAR(192, 168, 0, 1);
	delay_ms(500);
	get_GAR();
	delay_ms(1000);
	set_SIPAR(192, 168, 0, 100);
	delay_ms(500);
	get_SIPAR();
	set_SUBR(255,255,255,0);
	delay_ms(10);
	get_SUBR();
	delay_ms(500);
	set_SHAR(0x00, 0x08, 0xDC, 0xAB, 0xCD, 0xEF);
	delay_ms(500);
	get_SHAR();
	delay_ms(500);
	set_DIPR(192, 168, 0, 32);
	delay_ms(500);
	get_DIPR();

	set_RCR(1);
	set_RTR(0x1388); // 1388 decimal = 500 ms
	set_MR_noARP();

	set_SNMR0(1);
	delay_ms(500);
	get_SNMR0();
	delay_ms(500);
	set_SNCR(1);
	delay_ms(500);
	get_SNCR();
	delay_ms(500);
	get_SNSR();
	delay_ms(500);

	while(1){
//		send_macraw(SOCK_MACRAW,arp_packet,42);
		delay_ms(2000);
		set_SNMR0(1);
		delay_ms(500);
		get_SNMR0();
		delay_ms(500);
		set_SNCR(1);
		delay_ms(500);
		get_SNCR();
		delay_ms(500);
		get_SNSR();
		delay_ms(500);

		if (control == 0x13){
			set_DIPR(192, 168, 0, 32);
			delay_ms(10);
			set_SNSPR(5000);
			delay_ms(10);
			set_SNDPR(8081);
			delay_ms(10);
			set_SNCR(0x04);                 // CONNECT
			delay_ms(100);
			get_DIPR();
			delay_ms(100);
			get_SNSPR();
			delay_ms(100);
			get_SNDPR();
			delay_ms(100);
			get_SNSR();
			delay_ms(100);
			get_DHAR();

			// get request will start here
			if (control == 0x17){

				//  Read TX free size
				tx_free_size = get_Sn_TX_FSR(0);  // socket 0
				while (tx_free_size < get_len) {
					tx_free_size = get_Sn_TX_FSR(0);
				}

				//  Read current TX Write Pointer
				tx_wr_ptr = get_Sn_TX_WR(0);

				//  Calculate physical address in TX buffer
				uint16_t offset = tx_wr_ptr & 0x07FF;  // modulo 2 KB
				uint16_t addr = 0x0000 + offset;       // base = 0x0000 for socket 0

				W5500_Socket0_Write(offset, (uint8_t*)http_get_req, get_len);

				//  Update TX Write Pointer
				tx_wr_ptr += get_len;
				set_Sn_TX_WR(0, tx_wr_ptr);

				//    // 6️⃣ Send command
				set_SNCR(0x20);  // SEND command
				get_SNCR();
				while (control != 0x00) {
				}

				//  Poll RX buffer for response
				rx_size = W5500_Read16(0x0026); // Sn_RX_RSR
				while(rx_size == 0) {
				    rx_size = W5500_Read16(0x0026);
				}

				//  Read response from RX buffer
				uint16_t rx_ptr = W5500_Read16(0x0028); // Sn_RX_RD
				                // adjust size as needed
				for (uint16_t i=0; i<rx_size && i<512; i++) {
				    response[i] = W5500_Read(0x6000 + ((rx_ptr + i) & 0x07FF));
				}

				//  Update RX read pointer
				W5500_Write16(0x0028, rx_ptr + rx_size);

				set_SNCR(0x40); // RECV
				get_SNCR();
				while(control != 0);
			}
		}
		get_SNSR();
		if (control == 0x17){

			// Assume socket 0 is connected (ESTABLISHED)
			set_SNCR(0x08);   // CLOSE command → sends RST
			delay_ms(100);
//			set_SNCR(0x10);   // CLOSE command → sends RST
//			delay_ms(100);
			get_SNSR();       // Should now show CLOSED (0x00)
		}

	}
}



