/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"
#include "string.h"
#include "stdbool.h"
#include "stdio.h"
void GPIO_Init(void) {
	RCC->APB2RSTR |= RCC_APB2RSTR_IOPARST;
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPARST;
	RCC->APB2RSTR |= RCC_APB2RSTR_IOPBRST;
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPBRST;
	RCC->APB2RSTR |= RCC_APB2RSTR_IOPCRST;
	RCC->APB2RSTR &= ~RCC_APB2RSTR_IOPCRST;

	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN | RCC_APB2ENR_IOPCEN;

	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
	GPIOA->CRL &= ~(GPIO_CRL_MODE0 | GPIO_CRL_CNF0);   // PA0 analog
	GPIOA->CRL &= ~(GPIO_CRL_MODE1 | GPIO_CRL_CNF1);   // PA1 analog

	// PC15 as input (floating)
	GPIOC->CRH &= ~(GPIO_CRH_MODE15 | GPIO_CRH_CNF15);
	GPIOC->CRH |= GPIO_CRH_CNF15_1;    // CNF15 = 10 (input with pull-up/pull-down)
	GPIOC->BSRR = GPIO_BSRR_BS15;      // pull-up (use BR15 for pull-down)

}


void system_clk()
{
	//ENABLE HSE AND WAIT TILL IT BECOMES READY
	RCC->CR |= RCC_CR_HSEON;	//HSE @8MHZ
	while(!(RCC->CR & RCC_CR_HSERDY))
		;

	//CONFIGURE FLASH PREFETCH AND LATENCY SETTINGS
	FLASH->ACR |= FLASH_ACR_PRFTBE|FLASH_ACR_LATENCY_1;

	//CONFIGURE PLL AND BUSES (AHB,APB1,APB2)
	//PLL SOURCE: HERE HSE IS USED AS A SOURCE
	RCC->CFGR |= RCC_CFGR_PLLSRC;
	//HSE DIVIDER FOR PLL (IF HSE IS USED AS SOURCE FOR PLL)
	RCC->CFGR |= RCC_CFGR_PLLXTPRE_HSE;	//INPUT TO PLL 8MHZ
	//PLL MULTIPLIER: HERE HSE OUTPUT IS MULTIPLIED WITH 4
	RCC->CFGR |= RCC_CFGR_PLLMULL4;	//OUTPUT TO PLL IS 32MHZ
	//BUS CLOCK CONFIGURE(APB1,APB2,AHB): NOT DIVIDING
	RCC->CFGR |= (RCC_CFGR_PPRE1_DIV1|RCC_CFGR_PPRE2_DIV1|RCC_CFGR_HPRE_DIV1);
	//ENABLE THE PLL
	RCC->CR |= RCC_CR_PLLON;
	//WAIT FOR PLL TO SET
	while(!(RCC->CR & RCC_CR_PLLRDY))
		;

	//ENABLE SYSTEMCLK AND WAIT
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL))
		;

	GPIO_Init();
	//CLOCK OUTPUT ON MCO PIN
	RCC->CFGR |= RCC_CFGR_MCO_SYSCLK;
}


/* Timer Frequency (TF) = bus Clock(Fsysclk)/(Prescaler(TIM2PSC) + 1)
 *
 * Timer tim Period (TTM) = 1/timer frequency(TF)
 *
 * Time delay by timer = Timer Time Period * Timer Auto Reload Register(TIM2ARR)
 *
 * System clock = 32MHz, TIM2PSC = 32, so TF = 1MHz
 *
 * TTP = 1us
 * TIM2AEE = 0xffff
 */


void delay_us(uint16_t us) {
    uint16_t start = TIM2->CNT; // Capture the current counter value
    while ((TIM2->CNT - start) < us); // Wait until the elapsed time matches 'us'
}


void delay_ms(uint16_t ms){
	for (uint16_t i=0; i<ms; i++)
		delay_us(1000);
}

void timer_init(){
	//Start by making sure that the timer's 'counter' is off
	TIM2->CR1 &= ~(TIM_CR1_CEN);
	TIM2->SR &= ~(TIM_SR_UIF);

	//RESET THE TIMER2 BUS
	RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST);
	RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST);

	//ENABLE THE TIMER2 PERIPHERAL CLOCK
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;


	/**********Eg1************/
	//Timer Prescaler value
	TIM2->PSC = 31;

	//Timer Auto Reload Register Value
	TIM2->ARR = 0xffff;

	//ENABLE THE UPDATE GENERATION
	TIM2->EGR |= TIM_EGR_UG;

	TIM2->CR1 |=TIM_CR1_CEN;
//	while(!(TIM2->SR & (1<<TIM_SR_UIF)));
}
/* -- UART1 init using CMSIS GPIO macros (no numeric shifts) -- */
void uart1_init(void) {
    /* Enable clocks: GPIOA, USART1, AFIO */
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_USART1EN | RCC_APB2ENR_AFIOEN;

    /* PA9 (TX) -> MODE9 = 11 (output 50MHz), CNF9 = 10 (AF push-pull) */
    /* Clear MODE9 and CNF9 bits first */
    GPIOA->CRH &= ~(GPIO_CRH_MODE9 | GPIO_CRH_CNF9);
    /* Set MODE9 = 11 */
    GPIOA->CRH |= (GPIO_CRH_MODE9_0 | GPIO_CRH_MODE9_1);
    /* Set CNF9 = 10 -> CNF9_1 = 1, CNF9_0 = 0 */
    GPIOA->CRH |= GPIO_CRH_CNF9_1;
    GPIOA->CRH &= ~GPIO_CRH_CNF9_0;

    /* PA10 (RX) -> MODE10 = 00 (input), CNF10 = 01 (floating input) */
    GPIOA->CRH &= ~(GPIO_CRH_MODE10 | GPIO_CRH_CNF10);
    /* MODE10 already 00 after clear; set CNF10 = 01 */
    GPIOA->CRH |= GPIO_CRH_CNF10_0;
    GPIOA->CRH &= ~GPIO_CRH_CNF10_1;

    /* Baudrate for PCLK2 = 32 MHz, Baud = 9600:
       BRR = 32,000,000 / 9600 = 3333.333 -> 0x0D05 (mantissa 3333, fractional approx) */
    USART1->BRR = 0x0D05;

    /* Enable transmitter and USART (RX can be enabled too if desired) */
    USART1->CR1 = USART_CR1_TE | USART_CR1_UE;
}

/* -- Polling transmit -- */
void uart1_send_char(char c) {
    while (!(USART1->SR & USART_SR_TXE));
    USART1->DR = (uint8_t)c;
}

void uart1_send_string(const char *s) {
    while (*s) uart1_send_char(*s++);
}

uint16_t adc1_read_channel0(void) {
    ADC1->SQR1 &= ~ADC_SQR1_L;          // 1 conversion
    ADC1->SQR3 = 0;                     // channel 0

    ADC1->SMPR2 &= ~ADC_SMPR2_SMP0;     // clear
    ADC1->SMPR2 |= ADC_SMPR2_SMP0_2 | ADC_SMPR2_SMP0_1 | ADC_SMPR2_SMP0_0; // 239.5 cycles

    ADC1->CR2 |= ADC_CR2_ADON;          // start conversion
    while (!(ADC1->SR & ADC_SR_EOC));   // wait for end of conversion

    return (uint16_t)ADC1->DR;          // read result
}

uint16_t adc1_read(uint8_t channel) {
    ADC1->SQR1 &= ~ADC_SQR1_L;              // 1 conversion
    ADC1->SQR3 = channel & 0x1F;            // set channel number (0â€“17)

    ADC1->SMPR2 &= ~(0x7 << (3 * channel)); // clear sampling time bits
    ADC1->SMPR2 |=  (0x7 << (3 * channel)); // 239.5 cycles for accuracy

    ADC1->CR2 |= ADC_CR2_ADON;              // start conversion
    while (!(ADC1->SR & ADC_SR_EOC));       // wait for conversion to complete

    return (uint16_t)ADC1->DR;              // read ADC result
}

uint8_t read_pc15(void) {
    return (GPIOC->IDR & GPIO_IDR_IDR15) ? 1 : 0;
}

uint16_t adc0, adc1;
uint8_t button;
uint8_t ready;

char buf[32];

int main(void) {
    system_clk();
    timer_init();
    uart1_init();

    ADC1->CR2 |= ADC_CR2_ADON;
    for (volatile int i=0;i<1000;i++);
    ADC1->CR2 |= ADC_CR2_CAL;
    while (ADC1->CR2 & ADC_CR2_CAL);

    while (1) {
    	adc0 = 0;
    	adc1 = 0;
    	for(uint8_t i=0; i<10; i++){
			adc0 += adc1_read(0);  // PA0
			adc1 += adc1_read(1);  // PA1
    	}

    	adc0 /= 10;
    	adc1 /= 10;
    	if (ready >= 10) {
			if (adc0<1365){
				sprintf(buf, "Right\n");
				uart1_send_string(buf);
			} else if (1365<adc0 && adc0<2730){

			} else if (adc0>2730){
				sprintf(buf, "Left\n");
				uart1_send_string(buf);
			} else if (adc1<1365){
				sprintf(buf, "Forward\n");
				uart1_send_string(buf);
			} else if (1365<adc1 && adc1<2730){

			} else if (adc1>2730){
				sprintf(buf, "Backward\n");
				uart1_send_string(buf);
			}
			button = read_pc15();
			if (!button){
				sprintf(buf, "Button\n");
				uart1_send_string(buf);
			}
			ready = 0;
    	}
    	ready++;


        delay_ms(5);
    }

}

